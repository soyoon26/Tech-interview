### Promise

:Js 비동기 처리에 사용되는 객체

#### 콜백함수(Callback)

:특정 함수 내 **인자로 다른 함수**를 받아서 어떤 특징 시점에 도달했을 때 시스템에서 인자로 받은 함수를 호출하는 것
즉, **비동기 작업이 끝난 뒤 호출(Callback)**되는 함수

- 단점 : 콜백 패턴을 사용해 처리 순서를 보장하기 위해 중첩이 많이 생길 경우 코드 복잡도가 증가함
- 콜백 지옥(callback hell) :여러개의 비동기 작업을 순차적으로 수행해야 할 때, **콜백 함수가 중첩**되어 코드의 깊이가 깊어지는 현상 => 코드 가독성이 떨어지며 코드의 흐름을 파악하기 어려움, 콜백햄수마다 예외를 따로 처리해야 하고 에러가 발생한 위치를 추적하기 힘듦

### 프로미스(Promise)

: **ES6**에 추가된 문법, **콜백함수의 단점을 보완**하기 위해 등장하였으며 비동기 작업이 수행되어 결과를 반환하는 객체를 의미. 완료되면 resolve 메소드를 호출하고 작업이 실패하면 reject를 호출하는 함수

비동기 작업이 끝날 때까지 결과를 기다리는 것이 아니라 **결과를 제공하겠다는 '약속'**을 반환한다는 의미

### 프로미스 객체 사용법

:프로미스 객체를 **변수에 바로 할당**하는 방식

#### 프로미스 객체 생성

```
const promise = new Promise((resilve, reject) => {
	const data = fetch('요청 url'); // 비동기 작업 수행
    if (data) resolve(data); //성공하여 데이터가 있는 경우
    else reject("Error"); // 실패하여 데이터가 없는 경우
})
```

Promise 객체를 생성하려면 new키워드와 Promise 생성자 함수를 사용
Promise 생성자 안에 두 개의 매개변수를 가진 콜백 함수를 넣게 됨
첫 번째 인수: 작업이 성공했을 때 성공(resolve)임을 알려주는 객체
두 번째 인수: 작업이 실패했을 때 실패(reject)임을 알려주는 오류 객체

#### 프로미스 객체 처리

```
promise
	.then((value) => { // 성공시에 실행될 코드
    	console.log("Data: ",value); // resolve의 data
    }).catch((error) => { // 실패시 실행
    	console.error(error); // reject의 error
    })
```

#### 프로미스 함수 등록 방식

: 함수를 만들고 호출하면 프로미스 생성자를 return하여 곧바로 생성된 프로미스 객체를 함수 반환값으로 얻어 사용하는 방식

```
function pormise() {
	reurn new Promise((resilve, reject) => {
    	if (성공조건) {
        	resolve(결과);
        } else {
        	reject(에러값);
        }
    });
}
```

#### 장점 : 재사용성(필요할 때마다 호출), 가독성(비동기의 정의와 사용을 분리), 확장성(여러 개의 Promise 반환 함수들을 연결)

### 프로미스 체이닝(Promise Chaining)

: 프로미스 핸들러를 연달아 연결하는 것, **체이닝 기법**을 통해 비동기 작업을 순차적으로 수행가능
**then 핸들러에서 값을 return**하면 그 반환값은 자동으로 **프로미스 객체로 감싸져** 반환됨

### 프로미스 3가지 상채

- Pending(대기) : 프로미스 객체를 생성하고 처리가 **완료되지 않은** 상태(처리 진행중)
- Fulfilled(이행) : **성공**적으로 처리가 완료된 상태 => resolve 함수 호출
- Rejected(거부) : 처리가 **실패**로 끝난 상태 => reject 함수 호출

### 프로미스 핸들러

- .then() : 프로미스가 이행(fulfilled)되었을 때 실행할 콜백 함수 등록, 새로운 프로미스를 반환
- .catch() : 프로미스가 거부(rejected)되었을 때 실행할 콜백 함수 등록, 새로운 프로미스를 반환
  .finally() : 프로미스가 이행되거나 거부될 때 상관없이 실행할 콜백 함수 등록, 새로운 프로미스 반환

### 프로미스 정적 메서드

: 객체를 **초기화, 생성하지 않고도 바로 사용**할 수 있어 비동기 처리보다 효율적이고 산편하게 구현가능

- Promise.resolve() / Promise.reject()
- Promise.all() : 여러 개의 비동기 처리를 한 번에 병렬처리할 때 사용
  - 모든 프로미스가 fulfilled되면 모든 처리 결과를 배열에 저장해 새로운 프로미스 반환, 하나라도 reject되면 즉시 에러띄우고 종료 / API요청에 많이 쓰임
- Promise.allSettled() : 모두 처리되면 모든 프로미스 각각의 상태와 값/거부사유를 모아놓은 배열을 반환
- Promise.anu() : 주어진 모든 프로미스 중 하나라도 완료되면 바로 반환
- Promise.race() : 이행, 실패와 상관없이 무조건 처리가 끝난 프로미스 결과값 반환, 하나라도 fulfilled / reject되면 종료

### 프로미스 지옥

프로미스의 then() 메서드가 지나치게 체인되어 반복되면 코드가 길어지고 가독성이 떨어질 수 잇음 => 각 then 메서드가 어떤 값을 반환하는지 파악하기 어려움 + catch메서드가 마지막에 한 번만 사용되어 중간에 발생할 수 있는 에러나 예외 상황에 대응하기 어려움

따라서, 이를 극복하기 위해 ES8에서 도입된 async/await 키워드가 등장 => 프로미스를 기반으로 하지만 then과 catch메서드를 사용하지 않고 비동기 작업 수행 가능 + 비동기 작업을 동기작업처럼 쓸 수 있어 코드가 간결하고 가독성이 좋음
